using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading.Tasks;
using System.Xml.Serialization;
using CommandLine;
using InfectedRose.Database;
using InfectedRose.Database.Fdb;
using Microsoft.Data.Sqlite;
using RakDotNet.IO;

namespace InfectedRose.Interface
{
    public static class Program
    {
        public const string Version = "0.1";

        public static Options CommandLineOptions { get; set; }
        
        public static Dictionary<string, ModType> ModTypes { get; set; } = new Dictionary<string, ModType>();
        
        public class Options
        {
            [Option('i', "input", Required = false, HelpText = "Path to mods.json.")]
            public string Input { get; set; } = "mods.json";

            [Option('c', "copy", Required = false, HelpText = "Generate mods to copy this object LOT.")]
            public int CopyObject { get; set; } = 0;

            [Option('d', "id", Required = false, HelpText = "The id of the mod objects generated by copy.")]
            public string CopyId { get; set; } = "my-object";
            
            [Option('o', "output", Required = false, HelpText = "The file to output the generated mods to (when generating mods).")]
            public string Output { get; set; } = "output.json";
        }

        public static T ReadJson<T>(string file)
        {
            using var stream = File.OpenRead(file);

            return JsonSerializer.Deserialize<T>(stream) ?? throw new FileNotFoundException($"Could not find {file}!");
        }

        public static void WriteJson<T>(string file, T json)
        {
            using var stream = File.Create(file);
            
            var options = new JsonSerializerOptions();

            options.WriteIndented = true;
            options.DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull;

            JsonSerializer.Serialize(stream, json, options);
            
            stream.Close();
        }

        public static T ReadOrCreateJson<T>(string file) where T : new()
        {
            if (!File.Exists(file))
            {
                return new T();
            }
            
            using var stream = File.OpenRead(file);

            return JsonSerializer.Deserialize<T>(stream) ?? new T();
        }

        public static void ApplyRow(Mod mod)
        {
            if (mod.Action != "add")
            {
                return;
            }

            var tableName = ModContext.GetComponentTableName(mod.Type);

            if (!string.IsNullOrWhiteSpace(mod.Table))
            {
                tableName = mod.Table;
            }

            var table = ModContext.Database[tableName];

            if (table != null)
            {
                var row = table.Create();
            
                ModContext.RegisterId(mod.Id, row.Key);
                
                ModContext.ApplyValues(mod, row, table);
            }
            else
            {
                // For entries without tables, like the MissionNPCComponent
                ModContext.RegisterId(mod.Id, 0);
            }
        }

        public static void ApplyMod(Mod mod)
        {
            Console.Write("\t\u21B3 ");
            
            if (ModTypes.TryGetValue(mod.Type, out var type))
            {
                Console.ForegroundColor = ConsoleColor.Cyan;
                
                type.Apply(mod);
            }
            else
            {
                Console.ForegroundColor = ConsoleColor.Gray;

                ApplyRow(mod);
            }
            
            Console.WriteLine($"[{mod.Type}] \"{mod.Id}\"");

            Console.ResetColor();
        }

        public static void ApplyModFile(Manifest manifest, string file)
        {
            Mod[] mods = ReadJson<Mod[]>(file);

            var directory = Directory.GetCurrentDirectory();
            
            Directory.SetCurrentDirectory(Path.GetDirectoryName(file)!);
            
            foreach (var mod in mods)
            {
                ModContext.Mods[mod.Id] = mod;
                
                ApplyMod(mod);

                if (!mod.ShowDefaults.HasValue || mod.ShowDefaults.Value == false)
                {
                    foreach (var (key, value) in mod.Defaults)
                    {
                        if (mod.HasValue(key) && mod.Values[key].ToString() == value.ToString())
                        {
                            mod.Values.Remove(key);
                        }
                    }
                }
            }
            
            Directory.SetCurrentDirectory(directory);
            
            WriteJson(file, mods);
        }

        public static void ApplyManifest(string file)
        {
            Manifest manifest = ReadJson<Manifest>(file);
            
            Console.Write("Applying ");

            Console.ForegroundColor = ConsoleColor.Green;
            
            Console.WriteLine($"\"{manifest.Name}\"");
            
            Console.ResetColor();

            var directory = Path.GetDirectoryName(file)!;

            foreach (var modFile in manifest.Files)
            {
                ApplyModFile(manifest, Path.Combine(directory, modFile));
            }
        }

        public static void SaveDatabase()
        {
            // Save the database
            foreach (var table in ModContext.Database)
            {
                table.Recalculate();
            }
            
            ModContext.Database.Save(Path.Combine(CommandLineOptions.Input, "../../res/cdclient.fdb"));

            // Export the database as SQLite
            if (File.Exists(ModContext.Configuration.Sqlite))
            {
                File.Delete(ModContext.Configuration.Sqlite);
            }

            var connectionStringBuilder = new SqliteConnectionStringBuilder { DataSource = ModContext.Configuration.Sqlite };

            using var connection = new SqliteConnection(connectionStringBuilder.ConnectionString);
            
            connection.Open();
            
            ModContext.Database.SaveSqlite(connection);
            
            // Run sql commands specified by mods on the server
            foreach (var command in ModContext.ServerSql)
            {
                using var commandInstance = new SqliteCommand(command, connection);
                
                commandInstance.ExecuteNonQuery();
            }

            connection.Close();
        }

        public static async Task ConsoleRotateAnimation(Task other)
        {
            var index = 0;
            var array = new[] {"|", "/", "-", "\\", "|", "/", "-", "\\"};

            while (!other.IsCompleted)
            {
                await Task.Delay(100);
                    
                Console.Write(array[index++ % array.Length] + "\b");
            }
            
            Console.WriteLine();
        }

        public static Mod[] CopyObject(int lot, string id)
        {
            var objectsTable = ModContext.Database["Objects"];
            var componentsRegistryTable = ModContext.Database["ComponentsRegistry"];

            if (!objectsTable.Seek(lot, out var objectRow))
            {
                throw new Exception($"Failed to find object {lot} to copy!");
            }
            
            var componentRegistryRows = componentsRegistryTable.SeekMultiple(lot).ToArray();
            
            var mods = new List<Mod>();
            
            var objectMod = new Mod();
            mods.Add(objectMod);
            
            objectMod.Id = id;
            objectMod.Type = "object";
            
            var components = new List<string>();
            
            foreach (var registryRow in componentRegistryRows)
            {
                var componentId = (int) registryRow["component_id"].Value;
                var componentType = (ComponentId) registryRow["component_type"].Value;
                
                var componentMod = new Mod();
                mods.Add(componentMod);
                
                componentMod.Id = $"{id}:{componentType}";
                componentMod.Type = $"{componentType}";
                
                components.Add(componentMod.Id);

                if (!ModContext.Database[ModContext.GetComponentTableName(componentMod.Type)].Seek(componentId, out var componentRow))
                {
                    continue;
                }

                foreach (var field in componentRow.ToArray()[1..])
                {
                    if (field.Type == DataType.Nothing) continue;
                    
                    componentMod.Values[field.Name] = field.Value;
                }
            }

            objectMod.Components = components.ToArray();
            
            foreach (var field in objectRow.ToArray()[1..])
            {
                if (field.Type == DataType.Nothing) continue;
                
                objectMod.Values[field.Name] = field.Value;
            }

            return mods.ToArray();
        }
        
        public static void Main(string[] arguments)
        {
            // Parse command line arguments
            CommandLineOptions = Parser.Default.ParseArguments<Options>(arguments).Value;

            // Collect all implemented mod types
            foreach (var type in Assembly.GetExecutingAssembly().GetTypes())
            {
                var attribute = type.GetCustomAttribute<ModTypeAttribute>();

                if (attribute == null)
                {
                    continue;
                }

                ModTypes[attribute.Type] = Activator.CreateInstance(type) as ModType ?? 
                                           throw new InvalidOperationException($"Invalid mod type class {type}!");
            }
            
            // Store the root directory
            ModContext.Root = Directory.GetCurrentDirectory();
            
            ModContext.Configuration = ReadOrCreateJson<Mods>(CommandLineOptions.Input);

            // Load locale
            XmlSerializer localeSerializer = new XmlSerializer(typeof(Localization));

            var localeSourcePath = Path.Combine(Path.GetDirectoryName(CommandLineOptions.Input)!, "./locale.xml");
            var localeDestinationPath = Path.Combine(Path.GetDirectoryName(CommandLineOptions.Input)!, "../locale/locale.xml");

            if (!File.Exists(localeSourcePath))
            {
                File.Copy(localeDestinationPath, localeSourcePath);
            }

            using (var stream = File.OpenRead(localeSourcePath))
            {
                ModContext.Localization = (Localization) localeSerializer.Deserialize(stream)!;
            }

            // Check version
            if (string.IsNullOrWhiteSpace(ModContext.Configuration.Version))
            {
                ModContext.Configuration.Version = Version;
            }
            else if (ModContext.Configuration.Version != Version)
            {
                throw new Exception($"Version {Version} incompatible with mods.json version {ModContext.Configuration.Version}");
            }
            
            // Create the mods.json file or update it
            WriteJson(CommandLineOptions.Input, ModContext.Configuration);

            // Open database
            if (!File.Exists(ModContext.Configuration.Database))
            {
                var databaseSourcePath = Path.Combine(Path.GetDirectoryName(CommandLineOptions.Input)!, "./cdclient.fdb");
                var databaseDestinationPath = Path.Combine(Path.GetDirectoryName(CommandLineOptions.Input)!, "../res/cdclient.fdb");
                
                File.Copy(databaseDestinationPath, databaseSourcePath);
            }

            var origin = Console.GetCursorPosition();

            Console.Write("Starting  \b");

            var openDatabaseTask = Task.Run(() =>
            {
                var database = AccessDatabase.Open(ModContext.Configuration.Database);

                ModContext.Database = database;
            });

            var rotation = Task.Run(async () =>
            {
                await ConsoleRotateAnimation(openDatabaseTask);
            });

            Task.WaitAll(openDatabaseTask, rotation);

            Console.SetCursorPosition(origin.Left, origin.Top);

            if (CommandLineOptions.CopyObject != 0)
            {
                Console.Write($"Generating copy of {CommandLineOptions.CopyObject} as ");
                Console.ForegroundColor = ConsoleColor.Cyan;
                Console.Write($"[object] \"{CommandLineOptions.CopyId}\"");
                Console.ResetColor();
                Console.WriteLine($" to {CommandLineOptions.Output}");
                
                var mods = CopyObject(CommandLineOptions.CopyObject, CommandLineOptions.CopyId);
                
                WriteJson(CommandLineOptions.Output, mods);
                
                return;
            }
            
            // Sort the mods into a list of priorities
            List<string> priorities;

            if (ModContext.Configuration.Priorities.Count != 0)
            {
                ModContext.Configuration.Priorities.Sort((a, b) => a.Priority - b.Priority);

                priorities = ModContext.Configuration.Priorities.Select(m => m.Directory).ToList();
            }
            else
            {
                priorities = new List<string>();
                
                foreach (var file in Directory.GetFiles("./", "*manifest.json", SearchOption.AllDirectories))
                {
                    priorities.Add(Path.GetDirectoryName(file)!);
                }
            }

            // Apply the mods
            foreach (var priority in priorities)
            {
                ApplyManifest(Path.Combine(priority, "./manifest.json"));
            }
            
            // Check for unresolved references and print errors
            if (ModContext.IdCallbacks.Count > 0)
            {
                Console.ForegroundColor = ConsoleColor.Red;
                
                foreach (var callback in ModContext.IdCallbacks)
                {
                    Console.WriteLine($"Unknown reference to \"{callback.Id}\"");
                }
                
                Console.ResetColor();
                
                throw new Exception($"{ModContext.IdCallbacks.Count} unknown references found!");
            }
            
            // Create the lookup.json for ids
            var result = new Lookup();

            result.Ids = ModContext.Ids;
            
            WriteJson("lookup.json", result);

            origin = Console.GetCursorPosition();

            Console.Write("Saving  \b");
            
            var saveDatabaseTask = Task.Run(SaveDatabase);

            rotation = Task.Run(async () =>
            {
                await ConsoleRotateAnimation(saveDatabaseTask);
            });
            
            Task.WaitAll(saveDatabaseTask, rotation);

            Console.SetCursorPosition(origin.Left, origin.Top);

            using (var stream = File.Create(localeDestinationPath))
            {
                ModContext.Localization.Locales.Count = ModContext.Localization.Locales.Locale.Length;
                ModContext.Localization.Phrases.Count = ModContext.Localization.Phrases.Phrase.Count;
                
                localeSerializer.Serialize(stream, ModContext.Localization);
            }
            
            Console.WriteLine("Complete!");
        }
    }
}